        - using Plots
        - using Statistics
        - export p_dim,  hvIndicator
        - #TODO BiMADS
        - logocolors = Colors.JULIA_LOGO_COLORS
        - """
        - points for BiMADS Algo on the BiMADS map
        - """
        - mutable struct B_points
        -     cost::Vector{Float64}  #f1 and f2 value on BiMADS map
        -     x_now::Vector{Float64}
        -     weight::Int            #weight for each undominated point to determine the δ
        6     function B_points(cost::Vector{Float64},x::Vector{Float64}, w::Int=0)
     1950         p = new()
      975         p.cost = cost
      975         p.x_now=x
      975         p.weight = w
      975         return p
        -     end
        - end
        - """
        - Status for BiMADS main iteration, also contain stop conditions
        - 
        - """
        - mutable struct BiMADS_status
        -     iteration::Int64
        -     func_evaluation::Int64
        -     total_time::Float64
        -     hypervolume::Float64
        -     opt_status::OptimizationStatus
        -     opt_string::String
        -     start_time::Float64
       10     function BiMADS_status()
       22         s=new()
       22         s.iteration=0
       22         s.func_evaluation=0
       22         s.total_time=0.0
       22         s.hypervolume=0.0
       22         s.opt_status=Unoptimized
       22         s.opt_string="Unoptimized"
       22         s.start_time=time()
       22         return s
        -     end
        - end
        - 
        - function DTLZ2n2(x)
        - 
        -     # params
        -     M = 2; # Number of objectives
        -     n = 2; # Number of variables
        -     k = n - M + 1;
        - 
        -     # g(x)
        -     gx = sum((x[M:n] .- 0.5).^2);
        - 
        -     # functions
        -     ff = ones(M);
        -     ff1(x) = (1 + gx ) * prod(cos.(0.5 * pi * x[1:M-1]));
        - 
        -     ff2(x) = (1 + gx) * prod(cos.(0.5 * pi * x[1:M-2])) * sin(0.5 * pi * x[M - 2+ 1]);
        - 
        - 
        -     return ff1,ff2
        - 
        - end
        - 
        - function s(x)
        -     return abs(floor(x + 1 / 2) - x)
        - end
        - 
        - function f(x::Vector{Float64})
        -     Taka = 0
        -     w = 0.9
        -     for n = 1:100
        -         Taka -= w^n * s(2^n * x[1])
        -     end
        -     return Taka
        - end
        - 
        - function test1(x)
        -     f1(x) = ((x[1] + 2) .^ 2  - 10.0)
        -     # f2(x) = f(x)
        -     f2(x) = ((x[1] -2) .^ 2 +20)
        -     return f1, f2
        - end
        - 
        - function test2(x)
        -     f1(x) = (x[1] + 1) .^ 2 +(x[2] - 1) .^2 -10
        -     # f2(x) = (x[1] + 12) .^ 2 +(x[2] - 3) .^2 + 20.
        -     f2(x) = f(x)
        -     return f1*10,f2*10
        - end
        - 
        - function ex005(x)
        -     return [x[1]^2 - x[2]^2; x[1] / x[2]]
        - end
        - 
        - # p = DSProblem(2; objective = DTLZ2n2, initial_point = [0.,0.],iteration_limit=50, full_output = false);
        - p = DSProblem(1; objective = test1, initial_point = [0.],iteration_limit=500, full_output = false);
        - # p = DSProblem(2; objective = DTLZ2n2, initial_point = [0.,0.],iteration_limit=1000, full_output = false);
        - # SetIterationLimit(p,2)
        - 
        - SetFunctionEvaluationLimit(p,500000)
        - # AddStoppingCondition(p, RuntimeStoppingCondition(1.5))
        - # AddStoppingCondition(p, HypervolumeStoppingCondition(1.2))
        - # cons1(x) = x[1] > -1.
        - # AddExtremeConstraint(p, cons1)
        - # cons2(x) = x[1] <1.
        - # AddExtremeConstraint(p, cons2)
        - 
        - function plot_Bpoint(points::Vector{B_points})
        -     fig = Plots.scatter()
        -     for i = 1:length(points)
        -         fig = plot!([points[i].cost[1]],[points[i].cost[2]],seriestype = :scatter,aspect_ratio=1,legend = false,color=logocolors.red,show = true)
        -     end
        - return fig
        - end
        - 
        - function get_adj_dis(points::Vector{B_points})
        -     println("-----------------")
        -     for i=1:length(points)-1
        -         display(LinearAlgebra.norm(points[i+1].cost - points[i].cost)^2)
        -     end
        -     println("-----------------")
        - end
        - 
        - function paretoCoverage(paretoSet::Vector{B_points})::Tuple{Float64,Float64}
        -     points=Vector{Float64}()
        -     for i=1:length(paretoSet)-1
        -         push!(points,LinearAlgebra.norm(paretoSet[i+1].cost - paretoSet[i].cost)^2)
        -     end
        -     return mean(points), std(points)
        - end
        - 
        - 
        - """
        -     hvIndicator(paretoSet::Vector{B_points},factor=1.1)::Float64
        - 
        - Hyper-Volume indicator for evalating the Pareto Front
        - factor is used for choosing the referencepoint for hypervolume calculation
        - """
       10 function hvIndicator(paretoSet::Vector{B_points},factor=1.1)::Float64
       12     points=Vector{Vector{Float64}}()
       12     for i=1:length(paretoSet)-1
     1642         push!(points,paretoSet[i].cost)
        -     end
       12      ref=factor.*[last(points)[1],first(points)[2]]
        6      normalize_factor=(ref[1]-first(points)[1]).*(ref[2]-last(points)[2])./2
        6      hv_volume=0.
      830      area(x::Vector{Float64},y::Vector{Float64})=(abs(x[1]-y[1])).*(abs(x[2]-y[2]))
        6      for p in points
      824          hv_volume+=area(ref,p)
      830          ref[2]=p[2]
        -      end
        6      return hv_volume/normalize_factor
        - end
        - 
        - 
        - """
        -     p_split(p::DSProblem)::Tuple{DSProblem,DSProblem}
        - 
        - To split Bi-obj problem into two single obj problems
        - """
       20 function p_split(p::DSProblem)::Tuple{DSProblem,DSProblem}
       40     x = zeros(Float64, p.N)
       20     f1, f2 = p.objective(x)
       20     p1::DSProblem = deepcopy(p::DSProblem)
       20     p2::DSProblem = deepcopy(p::DSProblem)
       20     SetObjective(p1, f1)
       20     SetObjective(p2, f2)
       20     return p1, p2
        - end
        - 
        - """
        -     get_Bpoints(p1::DSProblem,p2::DSProblem,flag::Int)
        - 
        - Get the points to determine the reference point and Pareto front
        - flag for identifying optimize p1 or p2
        - """
       35 function get_Bpoints(p1::DSProblem, p2::DSProblem, flag::Int)
       35     temp_Bpoints = Vector{B_points}()
       35     Setup(p1)
        -     # push B_point for initial point
       35     flag == 1 &&
        -         push!(temp_Bpoints, B_points([p1.objective(p1.x), p2.objective(p1.x)],p1.x))
        - 
      919     while _check_stoppingconditions(p1)
      884         p1.full_output && OutputIterationDetails(p1)
      884         if OptimizeLoop(p1) == Dominating
      113             flag == 1 &&
        -                 push!(temp_Bpoints, B_points([p1.x_cost, p2.objective(p1.x)],p1.x))
      113             flag == 2 &&
        -                 push!(temp_Bpoints, B_points([p2.objective(p1.x), p1.x_cost],p1.x))
        -         end
        -     end
        - 
       35     Finish(p1)
        - 
       35     if p1.status.optimization_status != MeshPrecisionLimit && p1.status.optimization_status != PollPrecisionLimit
        5         error("The $(p1.status.optimization_status_string) is not enough for BiMADS, please increase it")
        -     end
       30     return temp_Bpoints
        - end
        - 
        - """
        -     pareto_front(points::Vector{B_points}, minimize = true)
        - 
        - find the Pareto points, only for this BiMADS.jl, not general methods
        - """
       41 function pareto_front(points::Vector{B_points}, minimize = true)
       78     cmp_strict = minimize ? (<) : (>)
       39     cmp = minimize ? (<=) : (>=)
       39     dims = 2 #number of objective functions, needs modification for multi-MADS
   966149     strictly_dominates(u::B_points, v::B_points) =
        -         all(cmp(u.cost[i], v.cost[i]) for i = 1:dims) &&
        -         any(cmp_strict(u.cost[i], v.cost[i]) for i = 1:dims)
     3975     undominated(p::B_points) =
        -         !any(
        -             strictly_dominates(p2::B_points, p::B_points) for
        -             p2 ∈ points if p2.cost != p.cost
        -         )
       39     filter!(undominated, points)
    30533     sort!(points, by = v -> v.cost, rev = false)
       39     return points
        - end
        - 
        - """
        -     initial_X_L(p1, p2)::Vector{Float64}
        - 
        - get the initial undominated points from p1 and p2
        - """
       14 function initial_X_L(p1, p2)::Vector{B_points}
       14     x_L = Vector{B_points}()
        -     # optmization for p1
       14     append!(x_L, get_Bpoints(p1, p2, 1))
       13     x_L = reverse(x_L)
        -     # optmization for p2
       13     append!(x_L, get_Bpoints(p2, p1, 2))
       13     return x_L
        - end
        - 
        - """
        -     get_ref(points::Vector{B_points})::Int
        - 
        - get the reference point for L>2
        - """
       26 function get_ref(points::Vector{B_points})::Int
     2994     dis(x::Int) = LinearAlgebra.norm(points[x].cost - points[x-1].cost)^2+LinearAlgebra.norm(points[x].cost - points[x+1].cost)^2
       26     max_index = 2 #point with largest distance to its adjacent points
       26     max_distance=0.
        - 
       52     for i = 2:length(points)-1
     2920         if dis(i)/(points[i].weight+1) >= max_distance
       48             max_distance = dis(i)/(points[i].weight+1)
     2942             max_index = i
        -         end
        -     end
       26     return max_index
        - end
        - 
        - 
        - """
        -     ReferencePointDetermination(undominated_points::Vector{B_points})::Tuple{Int,Float64,Vector{Float64}}
        - 
        - get the reference point for any case
        - """
       30 function ReferencePointDetermination(undominated_points::Vector{B_points})::Tuple{Int,Float64,Vector{Float64}}
       30     L=length(undominated_points)
       30     if L==1
        2         j=1
        2         ref_point=undominated_points[1].cost
        2         δ= 1.
       28     elseif L==2
        2         j=1 #different definition in paper(j=2) and books(j=1)
        4         ref_point=[undominated_points[2].cost[1],undominated_points[1].cost[2]]
        2         δ=(LinearAlgebra.norm(undominated_points[1].cost - undominated_points[2].cost)^2)/(undominated_points[2].weight+1)
        -     else
       26         j = get_ref(undominated_points)
       52         ref_point=[undominated_points[j+1].cost[1],undominated_points[j-1].cost[2]]
       26         δ=(LinearAlgebra.norm(undominated_points[j].cost - undominated_points[j-1].cost)^2
        -         +LinearAlgebra.norm(undominated_points[j].cost - undominated_points[j+1].cost)^2)/(undominated_points[j].weight+1)
        -     end
       30     undominated_points[j].weight+=1
       30     return j, δ, ref_point
        - end
        - 
        - """
        -     function phi(f1::Function,f2::Function, r::Vector{Float64}, x::Vector{Float64})
        - 
        - Auxiliary Function from BiMADS. Aim to refomulate the Bi-obj problem into
        - single-obj problem. Return the cost of the refomulated objective function
        - 
        - x is the point to be evaluated, r is the reference point
        - """
     7658 function phi(f1::Function,f2::Function, r::Vector{Float64}, x::Vector{Float64})
     7658     if (f1(x) <= r[1]) && (f2(x) <= r[2]) #if x dominant r
     7460         return -(r[1] - f1(x))^2 * (r[2] - f2(x))^2
      396     elseif (f1(x) == r[1]) || (f2(x) == r[2])
        0         return 0
        -     else
      198         return (max(f1(x) - r[1], 0))^2 + (max(f2(x) - r[2], 0))^2
        -     end
        - end
        - 
        - """
        -     update_p(p::DSProblem)
        - reset the reformulated problem for new MADS iteration
        - Including reset the Mesh/Poll size, IterationLimit, FunctionEvaluationLimit, RuntimeLimit, etc.
        - 
        - """
       16 function update_p_loop(p_init::DSProblem,p_reform::DSProblem,status::BiMADS_status)
        - 
       16     status.iteration+=p_reform.status.iteration
       16     status.func_evaluation+=p_reform.status.function_evaluations
       16     status.total_time=p_reform.status.runtime_total
       16     p_reform=deepcopy(p_init)
        - 
       16     for c in p.stoppingconditions
       64         i=_get_conditionindexes(p,typeof(c))[1]
       64         if c isa IterationStoppingCondition
       16             p_reform.stoppingconditions[i].limit=p_init.stoppingconditions[i].limit-status.iteration
       48         elseif c isa FunctionEvaluationStoppingCondition
       80             p_reform.stoppingconditions[i].limit=p_init.stoppingconditions[i].limit-status.func_evaluation
        -         end
        -     end
       16     return p_reform
        - end
        - 
       11 function update_p_init(p,p1::DSProblem,p2::DSProblem,status::BiMADS_status)
       11     for c in p.stoppingconditions
       47         i=_get_conditionindexes(p,typeof(c))[1]
       47         if c isa IterationStoppingCondition
       11             status.iteration=p1.status.iteration+p2.status.iteration
       11             p.stoppingconditions[i].limit-=status.iteration
       11             p.stoppingconditions[i].limit<=1 && error("The Iteration limit is not enough for BiMADS, please increase it")
       36         elseif c isa FunctionEvaluationStoppingCondition
       11             status.func_evaluation=p1.status.function_evaluations+p2.status.function_evaluations
       11             p.stoppingconditions[i].limit-=status.func_evaluation
       11             p.stoppingconditions[i].limit<=1 && error("The Function evaluation limit is not enough for BiMADS, please increase it")
       25         elseif c isa RuntimeStoppingCondition
        1             status.total_time=p1.status.runtime_total+p2.status.runtime_total
        1             p.stoppingconditions[i].limit -=status.total_time
       47             p.stoppingconditions[i].limit<=0 && error("The Runtime limit is not enough for BiMADS, please increase it")
        -         end
        -     end
        - end
        - 
       10 function update_p_end(p_reform::DSProblem,status::BiMADS_status)
       10     for c in p.stoppingconditions
       40         i=_get_conditionindexes(p,typeof(c))[1]
       40         if c isa IterationStoppingCondition
       10             status.iteration+=p_reform.status.iteration
       30         elseif c isa FunctionEvaluationStoppingCondition
       50             status.func_evaluation+=p_reform.status.function_evaluations
        -         end
        -     end
        - end
        - 
       34 function checkBiMADSStopping(p::DSProblem,status::BiMADS_status,undominated_points::Vector{B_points})::Bool
       34     if p.status.optimization_status!=PollPrecisionLimit &&p.status.optimization_status!=MeshPrecisionLimit
       16         status.opt_status=p.status.optimization_status
       16         return false
        -     end
        - 
       18     for c in p.stoppingconditions
       74         if c isa RuntimeStoppingCondition
        0             status.opt_status=RuntimeLimit
        0             i=_get_conditionindexes(p,RuntimeStoppingCondition)[1]
        0             (time()-status.start_time)>=p.stoppingconditions[i].limit && return false
        -         end
       74         if c isa HypervolumeStoppingCondition
        2             status.opt_status=HypervolumeLimit
        2             i=_get_conditionindexes(p,HypervolumeStoppingCondition)[1]
        2             status.hypervolume=hvIndicator(undominated_points)
       18             status.hypervolume>=p.stoppingconditions[i].limit && return false
        -         end
        -     end
        - 
       16     bb = bytesavailable(stdin)
       16     if bb>0
        0         println("quit")
        0         status.opt_status=KeyInterrupt
        0         return false
        -     end
        - 
       16     return true
        - end
        - 
        - """
        -     Optimize_Bi!(p::DSProblem)
        - 
        - Run the BiMADS algorithm on problem `p`.
        - 
        - `p` must have had its initial point and objective function set. If extreme
        - barrier constraints have been set then the initial point must be value for
        - those constraints.
        - """
       12 function Optimize_Bi!(p::DSProblem)
       12     println("BiMADS")
       12     status=BiMADS_status()
       12     p1::DSProblem, p2::DSProblem = p_split(p)
       12     f1 = p1.objective
       12     f2 = p2.objective
        -     # Initialization
       12     undominated_points = pareto_front(initial_X_L(p1, p2))
        - # display(undominated_points)
        - # display(plot_Bpoint(undominated_points))
        - 
       11     p_reform=deepcopy(p)
       11     update_p_init(p_reform,p1,p2,status)
        - 
       10     iteration_count=0
       10     ref_point=Vector{Float64}()
       10     j = 0     #initial point for the refomulated sigle-obj problem
       10     δ = 0.0 # quantify the quality of the coverage of the undominated points
        -             # here is the coverage of the point with largest distance to its adjacent points
        - # fig1=plot_Bpoint(undominated_points)
        - # fig2=plot_Bpoint(undominated_points)
        -     # Main iteration
       26     while true
       26         count=0
       26         println("===============================")
       26         println("Start of iteration ",iteration_count)
        -         #Reference point determination
       26         j, δ, ref_point=ReferencePointDetermination(undominated_points)
       26         println("j=",j,"  ref=",ref_point)
        -         #Single-objective formulation minimization
     7676         f_reform(x)=phi(f1,f2, ref_point, x)
       26         SetObjective(p_reform, f_reform)
       26         SetInitialPoint(p_reform,undominated_points[j].x_now)
        - 
        - # fig1=plot_Bpoint(undominated_points)
        - # p_reform.full_output=true
        -         #run MADS for refomulated problem and add new undominated points
       26         Setup(p_reform)
     2182         while _check_stoppingconditions(p_reform)
     2156             p_reform.full_output && OutputIterationDetails(p_reform)
     2156             if OptimizeLoop(p_reform) == Dominating
      838                     push!(undominated_points, B_points([p1.objective(p_reform.x), p2.objective(p_reform.x)],p_reform.x))
      838                     count+=1
        - # plot!(fig2,[p1.objective(p_reform.x)],[p2.objective(p_reform.x)],seriestype = :scatter,color=logocolors.blue)
        -             end
        -         end
       26         p_reform.status.runtime_total = time() - status.start_time
        - # fig2=plot_Bpoint(undominated_points)
        - 
       26         println("Add new points:",count)
        - # display(fig2)
        - 
        -         #update X_L
       26         pareto_front(undominated_points)
        - 
       26         iteration_count+=1
        - 
       26         !checkBiMADSStopping(p_reform,status,undominated_points) && break
       16         p_reform=update_p_loop(p,p_reform,status)
        - # length(undominated_points)>=474 && break
        -         # n_iteration>=p.stoppingconditions[1].limit ? (n_iteration+=1) : (n_iteration+=1)
        -         # display(undominated_points)
        -         # fig3=plot_Bpoint(undominated_points)
        -         # figall=plot(fig2,fig3,aspect_ratio=1)
        -         # savefig(figall, "/Users/zyy/Desktop/XJTLU/MSc_Project/Julia/test_julia/Results/DS_result_$(iteration_count-1).pdf");
        - # sleep(2)
        - # check()==1 && break
        - # if !isempty(input)
        - #     println("dd")
        - #     display(input)
        - #     break
        - # end
        -     end
        - 
       10     println("===============================")
       10     println("Total undominated points:", length(undominated_points))
       10     update_p_end(p_reform,status)
       10     println("Total Iterations: ",status.iteration)
       10     println("Total Function Evaluations: ",status.func_evaluation)
       10     println("Total Run Time: ",time()-p1.status.start_time)
       10     println("Optimization Status: ",status.opt_status)
       10     println("===============================")
       10     return undominated_points
        - end
        - 
        - # @time result=Optimize!(p)
        - # # display(result)
        - # display(paretoCoverage(result))
        - # display(hvIndicator(result))
        - # fig=scatter()
        - # for i in 1:length(result)
        - #     fig=scatter!([result[i].cost[1]],[result[i].cost[2]],color=logocolors.red,legend = false)
        - # end
        - # display(fig)
        - # savefig(fig, "/Users/zyy/Desktop/XJTLU/MSc_Project/Julia/test_julia/Results/DS_result_$(p.stoppingconditions[1].limit).pdf");
        - 
        - 
        - 
        - 
        - 
        - """
        -     p_dim(obj::Function,p.N)::Int
        - 
        - The dimension of the given objective function
        - """
       14 p_dim(p::DSProblem) = p_dim(p.objective, p.N)
       14 function p_dim(objective::Function, N::Int)::Int
       14     return length(objective(ones(N)))
        - end
